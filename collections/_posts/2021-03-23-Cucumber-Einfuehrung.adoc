= Einführung in BDD mit Cucumber
:page-category: Testing
:page-tags: [Cucumber, BDD, Testing]

Da ich mich in letzter Zeit beruflich mit **B**ehavior-**D**riven-**D**evelopment und Cucumber auseinandersetze, ist es naheliegend einen Artikel zu diesem Thema zu schreiben.
Dieser Artikel soll als Einführung in beide Themen dienen, wobei zunächst BDD und anschliessend Cucumber vorgestellt werden. 

== Was bedeutet BDD?

**B**ehavior-**D**riven-**D**evelopment ist eine kollaborative Methode, die sich perfekt in bestehende agile Entwicklungsprozesse integrieren lässt.
Durch die engere Zusammenarbeit wird die Lücke zwischen Fachexperten und Softwareentwicklern geschlossen und somit ein gemeinsames Verständnis über das zu lösende Problem erarbeitet.
Unterstützt wird dies durch schnelle, kleine Iterationen um gezielt kleine Teile des Systems anzupassen und so schneller Feedback zu erhalten und dieses zu verbessern.
Die konsequente Anwendung von BDD ermöglicht eine kontinuierliche Überprüfung und Dokumentation (lebendige Dokumentation) des Systemverhaltens.

BDD ist ein iterativer Prozess, der aus drei Schritten (Praktiken) besteht, der in der folgenden Abbildung dargestellt ist.

image::20210323/bdd_three_practices.svg["Drei Praktiken des BDD", title="Drei Praktiken des BDD"]

Alles beginnt mit einer https://de.wikipedia.org/wiki/User_Story[User Story], mit der das System geändert oder erweitert werden soll und endet mit funktionierender Software.
Mittendrin und somit im täglichen Prozess integriert stehen die drei Phasen _Discovery_, _Formulation_ und _Automation_.

=== Discovery

Eine initial formulierte User Story wird durch ein kurzes (ca. 30 Minuten), strukturiertes Meeting, genannt Discovery Workshop, mit allen Beteiligten (technisch und nicht technisch) in der Discovery Phase verfeinert.
Diese Meetings schärfen das gemeinsame Verständnis innerhalb des Teams bzgl. Geschäftsregeln und Umfang der Umsetzung. 
Dabei werden konkrete Beispiele aus Sicht der Endanwender*innen des Systems verwendet.
Das Benötigen von weiteren Infomationen um Verständnislücken zu schliessen oder die Verringerung des Umfangs der User Story könnten ein Outcome dieses Workshops sein. 

Bei den Discovery Workshops nimmt nicht das gesamte Team teil, als Daumenregel sollten drei bis sechs Personen teilnehmen. 
Dabei sollte darauf geachtet werden, dass mindestens die _Three Amigos_ aus den Bereichen Fach, Test und Entwicklung anwesend sind, um die verschiedenen Perspektiven zu berücksichtigen.

Für die Durchführung von Discovery Workshops gibt es verschiedene, kollaborative Methoden:

- https://cucumber.io/blog/bdd/example-mapping-introduction/[Example Mapping]
- https://johnfergusonsmart.com/feature-mapping-a-simpler-path-from-stories-to-executable-acceptance-criteria/[Feature Mapping]
- https://jennyjmar.com/2016/04/16/bdd-discovery-and-oopsi/[OOPSI Mapping (Outcome, Outputs, Processes, Scenarios, Inputs)]

=== Formulation

Nachdem in den Discovery Workshops Beispiele identifiziert wurden, werden diese in eine strukturierte Form überführt, die als Dokumentation bzw. Spezifikation dient.
Dadurch wird sichergestellt, dass ein gemeinsames Verständnis darüber existiert, was tatsächlich umgesetzt werden soll.

Dafür wird eine Sprache verwendet, die sowohl vom Menschen als auch von Maschinen verstanden wird. 
Im Falle von Cucumber erfolgt dies mittels https://cucumber.io/docs/gherkin/[Gherkin].
Ein einfaches Beispiel kann so aussehen:

[source, gherkin]
----
Feature: Add information to CV

  Scenario: An employee adds a certificate to the CV
    Given An empty CV
    When I add the certificate "Java SE 8 OCP" that I received on 12.03.2018 to my CV
    Then My CV contains the certificate "Java SE 8 OCP"
----

Durch die Verwendung von Gherkin können diese Szenarien automatisiert ausgeführt werden. 
Darüber hinaus kann das gesamte Team Feedback zu den formulierten Szenarien geben, da keine technischen Kenntnisse erforderlich sind.

Ein weiterer Vorteil in Hinblick auf Domain Driven Design ergibt sich durch die kollaborative Erstellung der Spezifikation, wodurch eine gemeinsame Sprache (Ubiquitous Language) etabliert werden kann.
Die Verwendung dieser Sprache in der Spezifikation trägt dazu bei, die Begriffe der Domäne auch im Code zu verankern.  

=== Automation

Im dritten Schritt werden die zuvor formulierten Beispiele automatisiert, in dem die einzelnen Testschritte mit dem zu testenden System verbunden werden.
Dies erfolgt über die Erstellung von sogenannten Glue-Code.

Die Automatisierung der Szenarien erfolgt schrittweise, ein Szenario nach dem anderen. 
Da die zu testende Funktionalität noch nicht implementiert ist, wird das entsprechende Szenario (analog zum TDD) zunächst fehlschlagen.
Anschliessend erfolgt die Implementierung der neuen Features, wobei weitere Szenarien erstellt werden, die das Verhalten von internen Systemkomponenten beschreiben und abdecken. 
Die Szenarien unterstützen bei der täglichen Implementierung und helfen den Fortschritt nachverfolgen zu können.

Auch bei der späteren Wartung des Systems oder der Einarbeitung von neuen Mitarbeitenden unterstützen die Szenarien, in dem sie helfen das aktuelle Verhalten des Systems zu verstehen. 
Darüber hinaus bilden sie ein Sicherheitsnetz und ermöglichen es Änderungen sicher und ohne ungewollte Seiteneffekte durchzuführen. 

== Cucumber

Cucumber ist ein BDD-Tool um Anforderungen an eine Software in natürlicher Sprache zu spezifizieren und diese automatisiert auf die korrekte Umsetzung zu überprüfen. 
Dabei wird das Verhalten eines Systems mithilfe von _Feature-Files_ unter Verwendung der https://martinfowler.com/bliki/GivenWhenThen.html[Given-When-Then]-Methode beschrieben. 
Die einzelne Schritte (Steps) werden mit Hilfe von _Glue-Code_ (https://cucumber.io/docs/cucumber/step-definitions/[Step-Definitions]) zur Ausführung gebracht.

Bevor ich im Folgenden auf die Möglichkeiten von _Feature-Files_ und den dazugehörigen _Glue-Code_ eingehe, zeige ich zunächst die Konfiguration von Cucumber im Zusammenspiel mit JUnit 5.

=== Konfiguration Cucumber mit JUnit 5

Um Cucumber mit JUnit 5 zu integrieren, werden drei Dependencies benötigt.

[source, xml]
----
<dependencies>
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter-api</artifactId> <1>
        <version>5.7.1</version>
        <scope>test</scope>
    </dependency>
    
    <dependency>
        <groupId>io.cucumber</groupId>
        <artifactId>cucumber-java8</artifactId> <2>
        <version>6.10.2</version>
        <scope>test</scope>
    </dependency>

    <dependency>
        <groupId>io.cucumber</groupId>
        <artifactId>cucumber-junit-platform-engine</artifactId> <3>
        <version>6.10.2</version>
        <scope>test</scope>
    </dependency>
</dependencies>
----
<1> Da wir JUnit 5 verwenden wollen, müssen wir das entsprechende API einbinden.
<2> Um bei der Step Definition die Java 8 Syntax verwenden zu können, wird diese Abhängigkeit benötigt. 
<3> Diese Abhängigkeit sorgt für die Integration von Cucumber mit JUnit 5.

[IMPORTANT]
====
Die Ausführung der Tests mit dem `maven-surefire-plugin` in Version `3.0.0-M5` funktioniert, jedoch wirken sich die
Testresultate nicht auf den Erfolg des Maven-Builds aus und die Szenarien werden nicht in die Testergebnisse aufgenommen.
Aus diesem Grund wurde im Codebeispiel die Version `2.22.2` verwendet.

Einen entsprechenden Bug habe ich im https://issues.apache.org/jira/browse/SUREFIRE-1896[Apache Jira] erstellt.
====

==== Testausführung

Damit Maven Surefire die Cucumber Szenarien entdecken und ausführen kann, ist ein Workaround notwendig (siehe https://github.com/cucumber/cucumber-jvm/tree/main/junit-platform-engine#surefire-and-gradle-workarounds[cucumber-junit-platform-engine]). 
Als Workaround wird eine leere Test Klasse angelegt und mit der `@Cucumber` Annotation versehen:

[source, java]
----
package ch.swb.cucumber.example;

import io.cucumber.junit.platform.engine.Cucumber;

@Cucumber
public class RunCucumberTest {

}
----

Durch diese Klasse wird Cucumber mitgeteilt in welchem Package die Feature-Dateien liegen. 
Diese müssen entsprechend im selben oder in einem darunterliegenden Package verortet sein. 
Die folgende Grafik zeigt die Struktur des `src/test/resources` Verzeichnisses:

.Verzeichnisstruktur
[plantuml, 20210323/src_test_resources, svg]
....
@startsalt
{
{T
 + src/test/resources
 ++ ch
 +++ swb
 ++++ cucumber
 +++++ introduction
 ++++++ add_information_to_CV.feature
 ++++++ remove_information_from_CV.feature
 ++ junit-platform.properties
}
}
@endsalt
....

In der Datei `junit-platform.properties` können der JUnit Platform verschiedenen Eigenschaften mitgeteilt werden.
Bei diesem Codebeispiel wurden folgende Eigenschaften gesetzt:

[source, properties]
----
cucumber.glue=ch.swb.cucumber <1>
cucumber.publish.quiet=true <2>
cucumber.plugin=pretty,html:target/site/cucumber-pretty.html <3>
----
<1> kommaseparierte Liste von package-Namen, in denen sich der Glue-Code befindet
<2> Unterdrückung der Ausgabe des Publish-Banners nach der Testausführung
<3> kommaseparierte Liste welche Plugins verwendet werden sollen

Eine Liste der untersützten Eigenschaften ist auf der https://github.com/cucumber/cucumber-jvm/tree/main/junit-platform-engine#configuration-options[GitHub-Seite] der Cucumber JUnit Platform Engine dokumentiert.

[NOTE]
====
Ein minimales Beispielprojekt für die Konfiguration von Cucumber mit JUnit 5 ist in meinem https://github.com/softwerkbank/cucumber-examples/tree/main/cucumber-junit5-example[GitHub Account] veröffentlicht.
====

=== Cucumber in Aktion

Nun wird es Zeit zu zeigen, wie sich mit Cucumber fachliche Tests schreiben lassen.
Um beispielsweise das im Abschnitt <<formulation>> gezeigte Szenario ausführbar zu machen, wird folgender Glue-Code benötigt:

[source, java]
----
public class CVStepDefs implements En {

  private CV cv;

  public CVStepDefs() {
    Given("An empty CV", () -> cv = new CV());

    When("I add the certificate {string} that I received on {date} to my CV", (String title, LocalDate date) -> {
      cv.addCertifcate(title, date);
    });

    Then("My CV contains the certificate {string}", (String title) -> {
      Optional<Certificate> certificate = cv.findCertificateByTitle(title);
      assertTrue(certificate.isPresent());
      assertEquals(title, certificate.get().title());
    });
  }
}
----

==== Lambdas vs. Annotations

- Verschiedene Möglichkeiten zeigen

==== Cucumber Expressions vs. Regular Expressions

- Parameter Types definieren

==== Parametrisierbare Tests 

- Scenario Outline

==== DataTable

- Die automatische Konvertierungen funktionieren nicht in der Java8 Lambda-Syntax https://github.com/cucumber/common/tree/main/datatable


==== Ausgangssituation für mehrere Szenarien definieren

- Background

==== Weitere Funktionalitäten

- Sprachen
- Before und After Hooks

==== Quellcode



== Fazit 
